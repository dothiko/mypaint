/* This file is part of MyPaint.
 * Copyright (C) 2017 by dothiko<dothiko@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef PYRAMIDFILL_HPP
#define PYRAMIDFILL_HPP

#include <Python.h>
#include <glib.h>

#include "pyramiddefine.hpp"

/* HOW IT WORKS : `pyramid-fill`
 *
 * This Module is for implementing python interface of
 * 'Pyramid-fill'
 *
 * I don't know how this should be called, so I named this as
 * Pyramid-fill. You can see images with googling 'pyramid mipmap'.
 * (Also, I want to avoid name-conflict/confusion around already existing
 * `surface-mipmap` of Mypaint.)
 *
 * Pyramid-fill is simular to mipmap, but not getting average,
 * get maximum pixel value (i.e. PIXEL_CONTOUR).
 * This is almost same as `max-pooling`
 *
 * And when pyramid creation completed, you will see
 * very large chunky pixels in the higher pyramid-level.
 * These chunky pixel acutually close gaps and avoid
 * spill out the flood-fill operation.
 *
 * Then we gradually progress pixels to downward of pyramid-level.
 * It gradually propergates `decided`(PIXEL_FILLED/PIXEL_OUTSIDE)
 * pixel value around neighbored `undecided`(PIXEL_AREA) pixels.
 * This operation also block holes of pixel contour.
 *
 * When propagation reached to level 0, identify undecided pixel area.
 * If it is neighbored too many `outside/invalid` pixels, reject them.
 * Otherwise, accept such pixel area as `decided` area.
 *
 * At last, we convert decided pixels as Mypaint colortiles,
 * and combine them to target layer.
 *
 * Finally, You'll get gap-closed filled pixels around there.
 */


/* Flagtile class, to contain pixel flag information.
 *
 * This class holds pixels in like a pyramid shape.
 * Actually, it is the same concept as `mipmap`,
 * but I named it `Pyramid` to avoid confusion with already existing `surface mipmap`.
 *
 * TODO: Currently, the flag buffer is allocated with C++ `new` function.
 *       This can be numpy buffer, to modefy the contents easily from python.
 */
class Flagtile
{
protected:

    uint8_t *m_buf;  

    PyObject *m_npbuf; // Python numpy object, Generated by lock method. 

    // Pixel counts. This stores how many pixels per pixel value in this tile.
    uint16_t m_pixcnt[MAX_PYRAMID+1][PIXEL_MAX];

    // buffer offsets of progress levels.
    static const int m_buf_offsets[MAX_PYRAMID+1];

    // Status bit flag for each tile.
    // It is Dirty flag, etc.
    int m_statflag;

    // Get antialias value(0.0 - 1.0) from Antialias pixel of flagtile.
    inline double get_aa_double_value(const uint8_t pix)
    {
        // 0.9 is practical factor, not to become alpha value too opaque.
        return ((((double)(pix)) / MAX_AA_LEVEL) * 0.9);
    }

    // Refresh m_pixcnt pixel count.
    // This is used to syncronize changes done at outside of this class.
    // You can access m_buf as numpy.array with lock method.
    void m_refresh_count()
    {
#ifdef HEAVY_DEBUG
        assert(m_statflag & COUNT_DIRTY);
#endif
        memset(m_pixcnt, 0, sizeof(uint16_t) * (MAX_PYRAMID+1) * PIXEL_MAX);
        uint8_t *ptr = m_buf;
        for(int l=0; l < MAX_PYRAMID; l++) {
            for(int i=0; i < PYRAMID_BUF_SIZE(l); i++) {
                uint8_t pix = *(ptr++);
                m_pixcnt[l][pix & PIXEL_MASK]++;
            }
        }
        // Until all references from other python objects is released,
        // pixels might be changed from outside.
        // So, continue re-counting.(So, it would be very slow!)
        if (m_npbuf == NULL)
            m_statflag &= (~COUNT_DIRTY);
    }

public:
    Flagtile(const int initial_value);

    virtual ~Flagtile();

    //// Pixel operation related.
    inline uint8_t get(const int level, const int x, const int y)
    {
        return *BUF_PTR(level, x, y);
    }
    inline uint8_t get_with_direction(const int level, 
                                      const int x, const int y, const int i)
    {
        return *BUF_PTR(level, x, y);
    }

    inline void replace(const int level, int x, int y, uint8_t val)
    {
        uint8_t oldpix = *BUF_PTR(level, x, y) & PIXEL_MASK;
        if ((val & PIXEL_MASK) != oldpix) {
            m_pixcnt[level][oldpix]--;
            m_pixcnt[level][(val & PIXEL_MASK)]++;
        }
        *BUF_PTR(level, x, y) = val;// Force update, because `val` might contain FLAG_ constants.
    }

    void clear_bitwise_flag(const int level, const uint8_t flag)
    {
        uint8_t *cp = BUF_PTR(level, 0, 0);
        for(int i=0; i < PYRAMID_BUF_SIZE(level); i++) {
            *cp &= (~flag);
            cp++;
        }
    }

    // Fill entire progress level pixels, with assigned value.
    void fill(const uint8_t val);

    void convert_from_color(PyObject *py_src_tile,
                            const int targ_r,
                            const int targ_g,
                            const int targ_b,
                            const int targ_a,
                            const double tolerance,
                            const double alpha_threshold,
                            const bool limit_within_opaque);

    void convert_to_color(PyObject *py_targ_tile,
                          const double r,
                          const double g,
                          const double b,
                          const int pixel);

    void convert_from_transparency(PyObject *py_targ_tile,
                                   const double alpha_threshold,
                                   const int pixel_value,
                                   const int overwrap_value);
    // Propagate upward until targ_level
    void propagate_upward(const int targ_level);
    // Propagete upward single level
    void propagate_upward_single(const int targ_level);

    //// Pixel count related
    inline bool is_filled_with(const int level, const int pix)
    {
        if ((m_statflag & COUNT_DIRTY) != 0)
            m_refresh_count();

        uint16_t cnt;
        if (pix == PIXEL_INVALID)
            cnt = m_pixcnt[level][PIXEL_EMPTY] 
                    + m_pixcnt[level][PIXEL_OUTSIDE];
        else
            cnt = m_pixcnt[level][pix & PIXEL_MASK];
        
        int level_tile_size = PYRAMID_TILE_SIZE(level);
        return cnt == (level_tile_size * level_tile_size);
    }

    inline int get_pixel_count(const int level, const int pix) {
        if ((m_statflag & COUNT_DIRTY) != 0)
            m_refresh_count();

        if (pix == PIXEL_INVALID)
            return m_pixcnt[level][PIXEL_EMPTY] 
                    + m_pixcnt[level][PIXEL_OUTSIDE];
        else
            return m_pixcnt[level][pix & PIXEL_MASK];
    }

    // lock/unlock, to access as numpy buffer from python.
    PyObject *lock(const bool readonly); 
    void unlock(PyObject *nparray); 

    //// Tile status related
    inline int get_stat() { return m_statflag; }
    inline void set_borrowed() {m_statflag |= BORROWED;}

    //// Tile Status flags.
    
    // This tile is a borrowed one from python dictionary.
    // i.e. this tile should not be deleted. just replace with NULL.
    static const int BORROWED = 0x00000001;

    // Pixel counter is invalidated by lock()/unlock() method.
    static const int COUNT_DIRTY=0x00000002;

    //// Pixel values related.
    // To Expose PIXEL_ values for python
    // without `contaminating` original mypaintlib namespace.
    static const int PIXEL_FILLED_VALUE = PIXEL_FILLED;
    static const int PIXEL_AREA_VALUE = PIXEL_AREA;
    static const int PIXEL_EMPTY_VALUE = PIXEL_EMPTY;
    static const int PIXEL_CONTOUR_VALUE = PIXEL_CONTOUR;
    static const int PIXEL_OUTSIDE_VALUE = PIXEL_OUTSIDE;
    static const int PIXEL_OVERWRAP_VALUE = PIXEL_OVERWRAP;
    static const int PIXEL_INVALID_VALUE = PIXEL_INVALID;
    static const int PIXEL_RESERVE_VALUE = PIXEL_RESERVE;

    static const int MAX_PYRAMID_LEVEL = MAX_PYRAMID;
};

/* Flagtile psuedo surface object.
 * This is the base class of fill operation classes.
 * This class is exposed to python, but cannot be used.
 */
class FlagtileSurface
{
protected:// Use protected, this is base-class.
    // The array of pointer of Flagtiles.
    Flagtile** m_tiles;

    // Shared buffer, for dummy empty tile.
    uint8_t *m_empty_shared_buf;
    uint16_t *m_empty_shared_cnt;

    // Origin x,y and surface width, height 
    // in TILE UNIT. 
    int m_ox;
    int m_oy;
    int m_width;
    int m_height;

    void generate_tileptr_buf(const int ox, const int oy,
                               const int w, const int h);

    // Offsets used for pixel search kernel.
    inline int get_tile_index(const int tx, const int ty)
    {
        return (ty * m_width + tx);
    }

    // Hide default constructor from python interface.
    FlagtileSurface();

public:
    virtual ~FlagtileSurface();

    //// Getter methods
    // Get origin and dimension - in TILE unit.
    // Origin is the starting point of this surface
    // in mypaint model(lib.document) .
    inline int get_origin_x() { return m_ox; }
    inline int get_origin_y() { return m_oy; }
    inline int get_width() { return m_width; }
    inline int get_height() { return m_height; }

    // Utility method to know actual surface size
    // in pyramid-level.
    inline int get_pixel_max_x(const int level)
    {
        return m_width * PYRAMID_TILE_SIZE(level);
    }

    inline int get_pixel_max_y(const int level)
    {
        return m_height * PYRAMID_TILE_SIZE(level);
    }

    // Tile getter methods.
    inline Flagtile* get_tile(const int tx, const int ty,
                              const bool request=false)
    {
        return get_tile(get_tile_index(tx, ty), request);
    }

    inline Flagtile* get_tile_from_pixel(const int level,
                                         const int sx, const int sy,
                                         const bool request)
    {
        int tile_size = PYRAMID_TILE_SIZE(level);
        int raw_tx = sx / tile_size;
        int raw_ty = sy / tile_size;

        // sx and sy should start from (0,0)
        // in every case.
        // Flagtilesurface reserves 1 tile around
        // of original tiles, and every pixel operation
        // MUST not exceed 64 pixel away(from original tiles).
        // Thus, when sx or sy is lower than zero, it is empty tile.
        if(raw_tx >= m_width || sx < 0
                || raw_ty >= m_height || sy < 0) {
            return NULL;
        }

        // above raw_tx/ty is zero-based,
        // adjusted by origin already.
        // so do not use get_tile_index,
        return get_tile(raw_ty * m_width + raw_tx, request);
    }

    inline Flagtile* get_tile(const int idx, const bool request=false)
    {
#ifdef HEAVY_DEBUG
        assert(idx < (m_width * m_height));
#endif
        Flagtile* ct = m_tiles[idx];
        if (ct == NULL) {
            if (request) {
                ct = new Flagtile(PIXEL_EMPTY);
                m_tiles[idx] = ct;
            }
        }
        return ct;
    }

    // Utility method, Check existence of a tile
    inline bool tile_exists(const int tx, const int ty)
    {
        return get_tile(tx, ty, false) != NULL;
    }

    inline uint8_t get_pixel(const int level,
                             const int sx, const int sy)
    {
        Flagtile *ct = get_tile_from_pixel(level, sx, sy, false);

        // If sx or sy exceeding the border of surface,
        // get_tile_from_pixel returns NULL, instead of m_empty_tile.
        if(ct == NULL) {
            return PIXEL_EMPTY;
        }

        const int tile_size = PYRAMID_TILE_SIZE(level);
        return ct->get(level,
                       POSITIVE_MOD(sx, tile_size),
                       POSITIVE_MOD(sy, tile_size));
    }

    inline void replace_pixel(const int level,
                              const int sx, const int sy,
                              const uint8_t val)
    {
        Flagtile *ct = get_tile_from_pixel(level, sx, sy, true);
#ifdef HEAVY_DEBUG
assert(ct != NULL);
#endif
        const int tile_size = PYRAMID_TILE_SIZE(level);
        ct->replace(level,
                    POSITIVE_MOD(sx, tile_size),
                    POSITIVE_MOD(sy, tile_size),
                    val);
    }

    //// Propagate methods.

    // Propagate base pixels upward level.
    void propagate_upward(const int max_level);

    // Propagate `Decided` pixels toward level 0.
    void propagate_downward(const int level, const bool expand_outside);

    ////  flood_fill method.
    // level has set up with Filler::set_target_level
    // before call flood_fill method.
    void flood_fill(const int sx, const int sy, Filler *w);

    // Also, filter method would be called from some worker classes.
    // Not for python.
    void filter_tiles(KernelWorker *k);
#ifdef _OPENMP
    // Parallelized version of filter_tiles. very limited usage.
    void filter_tiles_mp(KernelWorker *w);
#endif
    //
    // Utility Methods
    void convert_pixel(const int level, const int targ_pixel, const int new_pixel);

    // Identify pixels (and reject or accept)
    // by how many pixels touches `outside` pixels.
    void identify_areas(const int level,
                        const int targ_pixel,
                        const double accept_threshold,
                        const double reject_threshold,
                        const int accepted_pixel,
                        const int rejected_pixel,
                        int size_threshold=0);

    void dilate(const int pixel, const int dilation_size);

    // Finalize related methods.
    void fill_holes();
    void draw_antialias();
};


/* FloodfillSurface for flood-fill.
 */
class FloodfillSurface : public FlagtileSurface
{
private:
    // m_src_dict is to ensure exist a python dictinary
    // which contains Flagtile objects generated in
    // python code, by using Py_INCREF. 
    //
    // This object `DECREF`ed at destructor.
    PyObject* m_src_dict;

public:
    FloodfillSurface();
    virtual ~FloodfillSurface();

    void refer_tiledict(PyObject *tiledict);
    void borrow_tile(const int tx, const int ty, Flagtile *tile);
};

/* ClosefillSurface for close and fill.
 */
class ClosefillSurface : public FlagtileSurface
{
public:
    ClosefillSurface(const int min_x, const int min_y,
                     const int max_x, const int max_y);
    virtual ~ClosefillSurface();

    void draw_line(const int sx, const int sy,
                   const int ex, const int ey,
                   const int pixel);

    // Decide outside and inside pixels.
    void decide_outside(const int level);

    // Decide fillable area.
    void decide_area();
};

/* CutprotrudeSurface for `Cut protruding pixels` feature.
 * This class inherits from FloodfillSurface, because this borrows
 * python dictionary of Flagtiles previously generated/converted
 * like FloodfillSurface.
 */
class CutprotrudeSurface : public FloodfillSurface
{
public:
    CutprotrudeSurface();
    virtual ~CutprotrudeSurface();

    void remove_overwrap_contour();
};

//------------------------------------------------------------------------------ 
//// Other classes

// For floodfill, queuing flood-fill seed at border, as bitwise flags.
class BorderQueue
{
protected:
    // XXX Bitwise flag for each borders.
    // Assuming maximum tile-size as 64 pixel.
    uint64_t m_border[4];

    // m_incoming_dir is the direction where the flood-fill from.
    // e.g. if flood-fill spill to North, in `previous` operation,
    // that direction is inverted and stored in m_incoming_dir,
    // so `current` m_incoming_dir should be SPILL_SOUTH. 
    int m_incoming_dir;

    int m_tx;
    int m_ty;
    
    //Iterate border-seeded positions.
    //Actually, it is bitwise flag.
    //Do not expose m_border directly, because things might be changed
    //in future. Currently, I use single uint64_t for each border,
    //but if mypaint tile size is changed from 64 pixel, we cannot 
    //use uint64_t type as border-flag.
    inline int iter_seed_pos(int pos, const int dir, const int tile_size) {
        for(int i=pos;i < tile_size; i++) {
            if((m_border[dir] & ((uint64_t)1 << i)) != 0) {
                return i;
            }
        }
        return -1;
    }

public:
    // Initial constructor. use this at start point of flood-fill.
    BorderQueue(const int tx, const int ty, const int px, const int py) 
        : m_border(), 
          m_incoming_dir(SPILL_INIT),
          m_tx(tx),
          m_ty(ty)
    {
        m_border[0] = px;
        m_border[1] = py;
    }

    // `Spill out` constructor.
    // 
    // `border_dir` is the direction, where the seed came FROM.
    // The direction where `spill to` and `spill from` should be
    // opposite. So invert border_dir direction.
    BorderQueue(const int border_dir, BorderQueue *parent, const int tx, const int ty) 
        : m_border(),
          m_tx(tx), 
          m_ty(ty)  
    {
#ifdef HEAVY_DEBUG
        assert(parent != NULL);
        assert(border_dir < 4);
        assert(parent->m_border[border_dir] != 0);
#endif
        m_incoming_dir = (border_dir+2) & 3; // Reversed Direction.
        m_border[m_incoming_dir] = parent->m_border[border_dir];
    }

    virtual ~BorderQueue() {}

    static const int SPILL_NORTH = 0;
    static const int SPILL_EAST = 1;
    static const int SPILL_SOUTH = 2;
    static const int SPILL_WEST = 3;
    static const int SPILL_INIT = 4; // Initial floodfill seedpoint.
    static const int SPILL_ALL = 5; // To check all border with is_empty

    inline int get_incoming_dir() { return m_incoming_dir; }

    inline int get_tx(){return m_tx;}
    inline int get_ty(){return m_ty;}

    static int adjust_tx(int tx, int d) {
        // (d&1)+((d/3)*-2) is same as indexing `d` with array {0, 1, 0, -1}
        return tx + ((d&1)+((d/3)*-2));
    }
    static int adjust_ty(int ty, int d) {
        return adjust_tx(ty, (d+3)&3);
    }
    //// border seed related.

    inline void clear_border_seed() {
        m_border[m_incoming_dir] = 0;
    }

    inline void queue_border(const int dir, const int pos)
    {
        // With XOR, set seed or clear existing incoming-seed.
        m_border[dir] ^= ((uint64_t)1 << pos);
    }
    
    inline bool is_empty_queue(const int dir) 
    { 
        if (dir == SPILL_ALL) {
            for(int i=0; i < 4; i++) {
                if (m_border[i] != 0)
                    return false;
            }
            return true;
        }
        else {
            return m_border[dir] == 0; 
        }
    }

    // Special method for `completely filled` tile.
    // Invert all border seed flag, to spill out flood-fill
    // all direction except for incoming seeds.
    inline void invert_all_border() 
    {
        for(int i=0; i < 4; i++) {
            m_border[i] = ~(m_border[i]);
        }
    }

    // Generating working state GQueue.
    // This is used inside floodfill function.
    // NOTE: This method clears incoming seed flags.
    GQueue *get_working_state(const int level, Flagtile *t, Filler *w) 
    {
        const int tile_size = PYRAMID_TILE_SIZE(level);
        GQueue *gq = NULL;
        uint8_t pix;
        int x=0, y=0, idx=0;

        if (m_incoming_dir <= SPILL_WEST) {
            if (m_border[m_incoming_dir] == 0)
                return NULL;
            idx = iter_seed_pos(idx, m_incoming_dir, tile_size);
        }

        int offsets[] = {1, tile_size-1, 1, 0}; // `1` is placeholder.

        while(idx >= 0) {
            offsets[0] = idx;
            offsets[2] = idx;
            if (m_incoming_dir <= SPILL_WEST) {
                x = offsets[m_incoming_dir]; 
                y = offsets[(m_incoming_dir+3)&3]; 
            }
            else if (m_incoming_dir == SPILL_INIT){
                // Initial seedpoint
                x = (int)m_border[0];
                y = (int)m_border[1];
                // They are not seed flag.
                // so clear.
                m_border[0] = 0;
                m_border[1] = 0;
            }
#ifdef HEAVY_DEBUG
            assert(x >= 0);
            assert(x < tile_size);
            assert(y >= 0);
            assert(y < tile_size);
#endif
            pix = t->get(level, x, y);

            if (w->match(pix)) {
                if(gq == NULL)
                    gq = g_queue_new();   
                floodfill_point *seed_pt = (floodfill_point*)malloc(
                    sizeof(floodfill_point)
                );
                seed_pt->x = x;
                seed_pt->y = y;
                g_queue_push_tail(gq, seed_pt);
            }

            if (m_incoming_dir == SPILL_INIT)
                break;

            idx = iter_seed_pos(idx+1, m_incoming_dir, tile_size);
        }
        return gq;
    }

    // XXX for debug
    bool dbg_is_seed(int idx) {
        return m_border[idx] != 0;
    }
    int dbg_get_seed(int idx, int pos) {
        return (m_border[idx] >> pos) & 1;
    }
};

// Generic flood-fill worker. 
// This worker needs to be exposed to python, to execute flagtile_flood_fill.
class FloodFiller : public Filler
{
protected:
    uint8_t m_targ_pix;
    uint8_t m_fill_pix;

public:
    FloodFiller()
        : Filler() {}

    void set_target_pixel(const int targ_pixel, const int fill_pixel)
    {
        m_targ_pix = targ_pixel;
        m_fill_pix = fill_pixel;
    }
    // XXX Workaround:we don't need inherit this method, and this is
    // completely same as BaseWorker.
    // But SWIG seems to be not able to track `hided` base class method,
    // we must expose this at here to use this from python code.
    virtual void set_target_level(const int level)
    {
#ifdef HEAVY_DEBUG
        assert(level >= 0);
        assert(level <= MAX_PYRAMID);
#endif
        m_level = level;
    }

    virtual bool match(const uint8_t pix)
    {
        return (pix & PIXEL_MASK) == m_targ_pix;
    }

    virtual void step(Flagtile *t, const int x, const int y) 
    {
        t->replace(m_level, x, y, m_fill_pix);
    }

    virtual uint8_t get_fill_pixel(){ return m_fill_pix; }
    virtual uint8_t get_target_pixel(){ return m_targ_pix; }
};

//// functions

/* floodfill of Pyramid_fill version.
 * This would be used from python code, lib/tiledsurface.py
 */
bool
flagtile_flood_fill(Flagtile *t, BorderQueue *q, Filler *w);

#endif
